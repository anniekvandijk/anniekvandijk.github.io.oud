[ { "title": "How to embed small compiling .NET code examples in your blog", "url": "/posts/compiling-example-code/", "categories": "Blog, Styling", "tags": ".NET Fiddle, compiling, C#, .NET, dotnetfiddle.net, embedding code", "date": "2022-02-23 08:00:00 +0100", "snippet": "What do you need?All you need is a .NET Fiddle account and a saved Fiddle. A Fiddle is like a Github Gist, but only for .NET code.There are more tools online that can compile code. I chose .NET Fiddle, because it has nice code completion, Code Highlighting and can be embedded.How is this different from embedding a Github Gists?It is not very different. But, it will only show a nice block of code, which does not compile.Microsoft is developing a tool (Try .NET) that can run Gists in the browser. But it is not released to the public (yet). See Try .NET.Embed the FiddleIn the .NET Fiddle menu you press the ‘Share Button’ and copy the ‘Embed on Your Page code’. Then you paste the code block in your editor. It looks like this:&amp;lt;iframe width=&quot;100%&quot; height=&quot;475&quot; src=&quot;https://dotnetfiddle.net/Widget/c4S4dB&quot; frameborder=&quot;0&quot;&amp;gt;&amp;lt;/iframe&amp;gt;And now you have a running code block on your site :sunglasses:" }, { "title": "Running in-memory Integrations Tests for Azure Function on Github", "url": "/posts/running-in-memory-integrationtests-for-azure-functions/", "categories": "Test Automation, Azure Functions", "tags": "github, in-memory, github actions, integration tests", "date": "2022-02-18 10:00:00 +0100", "snippet": "Software development teams know: Integration Testing is hard! They are slow and have dependencies which make it difficult to run. But, This is not always true!In this post I describe how I made Integration Tests that run on an in-memory started Azure Function in an Github Actions workflow which is relatively fast. A second benefit, you do not have to deploy to test the function!What are we testing?I am developping an Azure Fuction with one HTTP endpoint (POST, form data) which returns a json.This is my endpoint:[Function(&quot;plantcheck&quot;)]public async Task&amp;lt;HttpResponseData&amp;gt; Run( [HttpTrigger(AuthorizationLevel.Function, &quot;post&quot;, Route = &quot;v1/plantcheck&quot;)] HttpRequestData request, FunctionContext executionContext){ await _handleRequest.CollectData(request.Body); var result = _matchData.MatchToxicPlantsForAnimals(); return await _handleResponse.SetResponse(request, result);}I am working in Visual Studio. When you run the Azure Function Locally (Without debug) you find it running on localhost:7071/api/v1/plantcheckIf I post a request with Postman, I get a 200 OK response with a response body.Ok, so this all looks great, let’s automate the first test for a request and response. I do notice that the response body is not as expected. Direct proof that only running Unit Test is not enough. This you only see of you hit the endpoint.Creating first automated Integration TestFor the Integration Tests, I made a seperate project and call it Function.IT. In my case, it is a .NET5 NUnit Testproject. I think I should rename Function.Tests to Function.UT, because that project is not containing all tests anymore … maybe I do rename it later :smile:The Function.IT project has one class file IntegrationTests. I made the example class more compact than the real one.public class IntegrationTests{ private static HttpClient _http; private const string Url = &quot;http://localhost:7071/api/v1/plantcheck&quot;; [SetUp] public void Setup() { _http = new HttpClient(); } [TearDown] public void Cleanup() { _http.Dispose(); } [Test] public async Task PlantcheckApi_ValidRequest_Returns200() { var request = new HttpRequestMessage { RequestUri = new Uri(Url), Method = HttpMethod.Post, Content = &amp;lt;somecontent&amp;gt; }; var response = await _http.SendAsync(request); var statusCode = (int)response.StatusCode; Assert.AreEqual(200, statusCode); }}The important parts are: a Setup for a new httpClient a TearDown to dispose the client a Test which posts something to the endpoint http://localhost:7071/api/v1/plantcheck that should return a http response code 200.When I run this test in Visual Studio, it should return the same result as the test in Postman.Notice the test time. It is not as fast as the Unit Tests, but not really slow too.All green, go to the next step.Adding the Integration Test to the Github Actions workflowI already have a Test workflow in Github Actions. For the Integration Tests I added the last 3 steps. Setup Azure Functions Core Tools, with a shell script to install Azure Functions Core Tools to run the Azure Function. Start function, with a shell script that starts the Azure Function. Integration test, To run the Integration Tests.name: Teston: push: branches: - main - developjobs: test: name: Test runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: fetch-depth: 0 # Shallow clones should be disabled for a better relevancy of analysis - name: Setup .NET uses: actions/setup-dotnet@v1 with: dotnet-version: 5.0.x - name: Dotnet Restore run: dotnet restore - name: Dotnet clean run: dotnet clean --configuration Debug - name: Dotnet Build run: dotnet build --no-restore --configuration Debug - name: Dotnet Unit test run: dotnet test Function.Test/Function.Tests.csproj --no-build --no-restore --verbosity normal --configuration Debug - name: Setup Azure Functions Core Tools shell: pwsh run: npm install -g azure-functions-core-tools@3 --unsafe-perm true - name: Start function shell: pwsh run: | dir $rootDir = $pwd.Path cd ./Function Start-Process -NoNewWindow func @(&quot;start&quot;,&quot;--verbose&quot;,&quot;false&quot;) Start-Sleep -s 60 cd .. - name: Integration test run: dotnet test Function.IT/Function.IT.csproj --no-build --no-restore --verbosity normal --configuration DebugEvery time a commit is pushed to the main or develop branch the Unit and Integration Tests are run. When they fail, nothing will be deployed to Azure.I hope this example will help with your tests! If you have any questions, please contact me or post a reaction to this post." }, { "title": "How to get emoji on your Jekyll Github pages", "url": "/posts/how-get-emoji-on-jekyll-github-pages/", "categories": "Blog, Styling", "tags": "jekyll, emoji, jemoji, github pages", "date": "2021-12-10 10:00:00 +0100", "snippet": "I am used to the emoji short text where you can put something like : blush : in your text and it pops up like a nice emoij :blush:. When I first did this on my blog, nothing happened.Apparently, you need to install a special compatible plugin jemoji to get the emoji working on Github pages. The short manual:StepsAdd the following to your site’s Gemfilegem &#39;jemoji&#39;And add the following to your site’s _config.ymlplugins: - jemojiIf you are working on a local machine, run$ bundle installIf not, just do a new commit to your Jekyll repository and it will trigger the new plugin to be build.Links About GitHub Pages and Jekyll Jemoji Github repository Emoji Cheat Sheet" }, { "title": "How I started a free blog with Github, Jekyll and Chirpy in 10 minutes", "url": "/posts/how-start-free-blog-with-github/", "categories": "Blog, General", "tags": "jekyll, github, github pages, chirpy, markdown, jekyll theme starter", "date": "2021-12-08 13:20:00 +0100", "snippet": "This is my first post ever on a personal blog page. Why now?I am working on a new project, and I have some trouble finding information to help solve some challenges. I really like when someone takes the time to write a helpful article. So, I figured, this time maybe it is my turn to create some blog posts about my challenges and how I solved it.My first challenge to write about is how to get a free blog site. You can publish on a site like Medium really ease, but the problem is, you have no influence over this site and what they do with your post.Then I discovered Github Pages. You can start a free blog on Github really easy. What I did: Login to my a Github account Find a Jekyll theme I liked with a Theme Starter Create Github Pages Site with the Theme Starter Learn some Markdown and made my first blog Publish the blog Change site settings Things I did afterwards and some tipsWhat do all this names mean?Github is a place where people all over the world store and share their software and work together on software. Github Pages is for hosting websites for your project information on Github. But you can do other things like hosting a blog website for personal use.Jekyll is a blog-aware static site generator. Yehhh! It means it spits out plain text and shows it on a website. You do not have to be a developer to make nice websites!Chirpy, my theme with a nice Theme Starter.Plain text is a bit boring. So some styling would be nice! Markdown is a lightweight markup language that you can use to add formatting elements to plain text files.Step 1. Login to my a Github accountSo I have a github account, but if you do not have an account, go to https://github.com and make a GitHub Free account. Pay attention to your username, because this will be visible in your blog url.My accountname is anniekvandijk and my final blog url is https://anniekvandijk.github.ioStep 2. Find a Jekyll theme I liked with a Theme StarterA nice starting point I found is jekyllthemes.io. There I found Minimal Mistakes, one of the most popular themes with a starter. But, after some googling, I found Chirpy. Also a nice theme with a Theme Starter which I liked more. You can find the Theme Starter here.Step 3. Create Github Pages Site with the Theme StarterSo I clicked on the Theme Starter link and it redirected me to the page where you can create a new repository. The Heading of the page:Create a new repository from chirpy-starterThe new repository will start with the same files and folders as cotes2020/chirpy-starter.To make a Github Pages repository, the name of the repository must be in a special format:&amp;lt;username&amp;gt;.github.ioBecause my username is anniekvandijk, I make a repository with the name anniekvandijk.github.io. Also, it has to be a public repository. When I pressed the Create repository from template button. After a few seconds I had a new repository with one branch (main) and all files I needed in it. Github has a build in publish functionality for Jekyll. It automatically publishes your changes on the main branch. Some starters have their own publish strategy. You will recognize these by the .nojekyll file in the root directory. Which blocks building the site by Github.Chirpy has that .nojekyll and uses Github actions to publish the site on a separate branch named gh-pages. This branch is created when saving the first blog.Step 4. Learn some Markdown and made my first blogMarkdown is great by its powerful but minimal and easy to learn functionality. Best is just to learn it by writing your first blog. This is a nice Markdown Cheat Sheet I used.To write my first blog I created a new file in the _posts folder with this format: YEAR-MONTH-DAY-title.md, example: 2021-12-16-my-first-blog.md. This is all default for a Jekyll site.Then first add this to the top of the file:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG names should always be lowercase---These are my first lines:---title: How I started a free blog with Github and Jekyll in 10 minutesdate: 2021-12-08 13:20:00 +0100categories: [General, Blog]tags: [jekyll, github, github pages, chirpy, markdown, yekyll theme starter]---And after that you can start writing in markdown.# Welcome**Hello world**, this is my first Jekyll blog post.I hope you like it!So after some time I was satisfied and commited the blog at the bottom of the page.Step 5. Publish the blogIf you commit the first post (at the bottom of the page). It will be saved in the _post directory, but there is happening more! In the background, a process runs to create all files for the blog site. This files are put into a new branch named gh-pages.The last thing I have to do to get my site online is switching the default Github Pages branch from main to gh-pages. Go to the Settings of your repository to the Pages section and change the Source branch from main to gh-pages.After hitting save my site should be running on https://anniekvandijk.github.io, and it it!Step 6. Change site settingsMy blog is posted and it looks fine. But to get all in place, I have to edit some settings in the config file and some other files. Things you can - or need to edit - is different for every theme. But most of the time things like social media names and urls need to be changed to point to your information.I found 3 settings files I changed:_config.yml_data/contact.yml_data/share.ymlI changed things like this in the _config.yml. The other files speak for themselves.I did have some trouble with getting my avatar in the right place. I made a new folder in the root, named assets and put my avatar in there. When building, it will be merged in the _site/assets folder. And I changed the avatar path like this:# the avatar on sidebar, support local or CORS resourcesavatar: &#39;/assets/avatar.jpg&#39;In the assets folder you can also put your images you use in the blogs. My blog images I put in a directory /assets/img/blog-images/\\&amp;lt;blogpagename&amp;gt;/, now I know which images belong to which blog.One of the things I do not like about this theme is the integration with Discus. I kept it disabled. I am looking for another Comments system. Also I want some other styling for the pictures and a heading picture in the posts section. And Emoji, which do not seem to work right now. But first, publish this and then move on do other fun stuff :smile:Things I did afterwards and some tips I cloned the repository locally to run it on my computer to see the results better in (a real browser) without publishing. You can clone the repository to your local machine and run your website there until you are satisfied and then push the changes to the main branch. you need a IDE like Visual Studio Code and some local installation of Ruby and Jekyll. Don’t forget to install a Markdown extension in VS Code. You can find information for local running and more on the official Jekyll site. I work in a separate branch for a new post, to save more often without publishing. Use a separate ‘branch’ until you think the post is good enough and then ‘merge’ it with your main branch with a ‘pull request’. When you start commit a post, you can choice to save it to a different branch. Make a good decission about the template you want to use. Changing it afterwards is not always easy. So it needs to fit your needs as good as possible. Installation instructions are all different. If you are more technical, you can try some advanced installs, else, really try to get a theme with a Theme Starter. " } ]
